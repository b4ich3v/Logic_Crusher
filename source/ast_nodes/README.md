### **Обща концепция**

Кодът дефинира структури за представяне и обработка на Булеви изрази чрез абстрактно синтактично дърво (AST). Всеки вид Булева операция (например AND, OR, NOT) е представен чрез свой собствен клас, който наследява от базовия клас `Node`. Това позволява на програмата да манипулира и анализира изразите по структуриран начин, като предоставя методи за опростяване, оценка, преобразуване в Жегалкинова полиномна форма и визуализация чрез Graphviz.

### **Базов клас `Node`**

- **Методи:**
    - `simplify()`: Опитва се да опрости възела и неговите под-възли, ако е възможно.
    - `evaluate(env)`: Изчислява стойността на израза при дадено присвояване на променливите (`env`).
    - `to_zhegalkin(variables)`: Преобразува израза в Жегалкинова полиномна форма, използвайки списъка с променливи.
    - `__eq__(other)`: Сравнява два възела за равенство въз основа на техните атрибути.
    - `substitute(env)`: Заменя променливите в израза с константи, ако са зададени в `env`.
    - `to_graphviz(dot, counter)`: Добавя възела в Graphviz графа за визуализация на израза.

### **Класове за специфични операции**

1. **`VariableNode`**
    - Представлява променлива в Булев израз (напр. `A`, `B`).
    - При опростяване не се променя, тъй като променливите не могат да бъдат опростени допълнително.
    - При оценка връща стойността на променливата от дадената среда (`env`).
    - При преобразуване в Жегалкинова форма, представя променливата като мононим с една променлива.
    - При заместване, ако променливата има зададена стойност в `env`, я заменя с константа (`ConstNode`), иначе остава непроменена.

2. **`ConstNode`**
    - Представлява константа в Булев израз (`0` или `1`).
    - При опростяване остава непроменен, тъй като константите не могат да се опростяват допълнително.
    - При оценка връща стойността на константата.
    - При преобразуване в Жегалкинова форма, `1` се представя като константен член `{0}`, а `0` като празен сет `{}`.
    - При заместване, константите остават непроменени.

3. **`NotNode`**
    - Представлява отрицание (NOT) на даден операнд.
    - При опростяване:
        - Двойното отрицание (`NOT(NOT x)`) се опростява до самия операнд (`x`).
        - Отрицание на константа се опростява до обратната стойност на константата.
    - При оценка връща обратната стойност на операнда.
    - При преобразуване в Жегалкинова форма, `NOT x` се представя като `1 + x` в GF(2).
    - При заместване, ако операндът има зададена стойност в `env`, се заменя и се опростява.

4. **`AndNode`**
    - Представлява логическо И (AND) между два операнда.
    - При опростяване:
        - Ако един от операндите е константа:
            - `True AND x` се опростява до `x`.
            - `False AND x` се опростява до `False`.
        - Ако двата операнда са еднакви, се опростява до един от тях.
    - При оценка връща логическото И на стойностите на операндите.
    - При преобразуване в Жегалкинова форма, `AND(x, y)` се представя като произведение `x * y` в GF(2).

5. **`OrNode`**
    - Представлява логическо ИЛИ (OR) между два операнда.
    - При опростяване:
        - Ако един от операндите е константа:
            - `True OR x` се опростява до `True`.
            - `False OR x` се опростява до `x`.
        - Ако двата операнда са еднакви, се опростява до един от тях.
    - При оценка връща логическото ИЛИ на стойностите на операндите.
    - При преобразуване в Жегалкинова форма, `OR(x, y)` се представя като `x + y + x*y` в GF(2).

6. **`XorNode`**
    - Представлява изключващо ИЛИ (XOR) между два операнда.
    - При опростяване:
        - `False XOR x` се опростява до `x`.
        - `True XOR x` се опростява до `NOT x`.
        - `x XOR x` се опростява до `False`.
    - При оценка връща изключващото ИЛИ на стойностите на операндите.
    - При преобразуване в Жегалкинова форма, `XOR(x, y)` се представя като `x + y` в GF(2).

7. **`ImpNode`**
    - Представлява импликация (IMP) между два операнда.
    - При опростяване, използва логическата еквивалентност `A IMP B = NOT A OR B`.
    - При оценка връща стойността на импликацията според стойностите на операндите.
    - При преобразуване в Жегалкинова форма, импликацията се представя като `1 + A + A*B` в GF(2).

8. **`EqvNode`**
    - Представлява еквивалентност (EQV) между два операнда.
    - При опростяване, използва логическата еквивалентност `EQV(A, B) = NOT (XOR(A, B))`.
    - При оценка връща резултата от еквивалентността според стойностите на операндите.
    - При преобразуване в Жегалкинова форма, еквивалентността се представя като `1 + x + y` в GF(2).

9. **`NandNode`**
    - Представлява NAND операцията между два операнда.
    - При опростяване, използва еквивалентността `NAND(A, B) = NOT (AND(A, B))`.
    - При оценка връща обратната стойност на логическото И на операндите.
    - При преобразуване в Жегалкинова форма, `NAND(A, B)` се представя като `1 + A*B` в GF(2).

10. **`NorNode`**
    - Представлява NOR операцията между два операнда.
    - При опростяване, използва еквивалентността `NOR(A, B) = NOT (OR(A, B))`.
    - При оценка връща обратната стойност на логическото ИЛИ на операндите.
    - При преобразуване в Жегалкинова форма, `NOR(A, B)` се представя като `1 + A + B + A*B` в GF(2).

### **Методи за опростяване (`simplify`)**

Всеки клас, представляващ логическа операция, има метод `simplify()`, който опитва да опрости израза според Булевите тъждества:

- **Константи**: Не се опростяват.
- **Променливи**: Не се опростяват.
- **NOT**:
    - Двойно отрицание (`NOT(NOT x)`) се опростява до `x`.
    - Отрицание на константа се опростява до обратната стойност (`NOT(True) = False`).
- **AND**:
    - `True AND x = x`
    - `False AND x = False`
    - `x AND x = x`
- **OR**:
    - `True OR x = True`
    - `False OR x = x`
    - `x OR x = x`
- **XOR**:
    - `False XOR x = x`
    - `True XOR x = NOT x`
    - `x XOR x = False`
- **IMP**:
    - `A IMP B = NOT A OR B`
- **EQV**:
    - `EQV(A, B) = NOT (A XOR B)`
- **NAND**:
    - `NAND(A, B) = NOT (A AND B)`
- **NOR**:
    - `NOR(A, B) = NOT (A OR B)`

### **Методи за оценка (`evaluate`)**

Всеки клас има метод `evaluate(env)`, който изчислява стойността на израза при дадено присвояване на променливите (`env`):

- **Променливи**: Връщат стойността им от `env`.
- **Константи**: Връщат собствената си стойност.
- **NOT**: Връща обратната стойност на операнда.
- **AND**: Връща логическото И на операндите.
- **OR**: Връща логическото ИЛИ на операндите.
- **XOR**: Връща изключващото ИЛИ на операндите.
- **IMP**: Връща резултата от импликацията `(NOT A) OR B`.
- **EQV**: Връща резултата от еквивалентността `A == B`.
- **NAND**: Връща обратната стойност на `A AND B`.
- **NOR**: Връща обратната стойност на `A OR B`.

### **Методи за преобразуване в Жегалкинова полиномна форма (`to_zhegalkin`)**

Всеки клас има метод `to_zhegalkin(variables)`, който преобразува израза в Жегалкинова полиномна форма в полевата алгебра GF(2):

- **Променливи**: Представят се като мононим с една променлива.
- **Константи**: `1` се представя като `{0}`, а `0` като празен сет.
- **NOT**: `NOT x = 1 + x`.
- **AND**: `AND(x, y) = x * y`.
- **OR**: `OR(x, y) = x + y + x*y`.
- **XOR**: `XOR(x, y) = x + y`.
- **IMP**: `IMP(A, B) = 1 + A + A*B`.
- **EQV**: `EQV(A, B) = 1 + A + B`.
- **NAND**: `NAND(A, B) = 1 + A*B`.
- **NOR**: `NOR(A, B) = 1 + A + B + A*B`.

### **Методи за заместване (`substitute`)**

Методът `substitute(env)` позволява заместване на променливите с константи според дадена среда (`env`). Например, ако имаме израз `A AND B` и `env = {'A': True}`, то след заместване изразът става `True AND B`, което може да се опрости до `B`.

### **Метод за визуализация (`to_graphviz`)**

Всеки клас има метод `to_graphviz(dot, counter)`, който добавя текущия възел към Graphviz графа за визуализация на израза. Това е полезно за генериране на графични представяния на Булевите изрази, което може да помогне при анализа и дебъгването.

### **Примери за опростяване и оценка**

- **Пример 1: `A AND True`**
    - **Опростяване**: `A AND True` се опростява до `A`.
    - **Оценка**: Ако `A = True`, резултатът е `True`; ако `A = False`, резултатът е `False`.

- **Пример 2: `NOT (NOT A)`**
    - **Опростяване**: `NOT (NOT A)` се опростява до `A`.
    - **Оценка**: Ако `A = True`, `NOT (NOT A) = True`; ако `A = False`, `NOT (NOT A) = False`.

- **Пример 3: `A XOR A`**
    - **Опростяване**: `A XOR A` се опростява до `False`.
    - **Оценка**: Независимо от стойността на `A`, `A XOR A = False`.

### **Пример за преобразуване в Жегалкинова полиномна форма**

- **Израз:** `A OR B`
    - **Жегалкинова форма:** `A + B + A*B`

- **Израз:** `NOT (A AND B)`
    - **Жегалкинова форма:** `1 + A*B`

---
